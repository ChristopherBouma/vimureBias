---
title: "üíª VIMuRe Tutorial"
subtitle: "VIMuRe v0.1.0 (latest)"
---

# ‚öôÔ∏è Setup

**Import packages**

```{r setup, warning=FALSE, message=FALSE}
library(dplyr)
library(knitr)

library(igraph)
library(vimure)

library(reshape2)
library(ggplot2)
```

# üì• Load the data

Here, we'll use the `vimure` package to model social networks from a village in Karnataka, India, gathered as part of a project studying the adoption of microfinance ([Banerjee et al, *Science*](https://doi.org/10.1126/science.1236498)). The data files we use here are derived from those openly-available on [the Harvard Dataverse page](https://dataverse.harvard.edu/dataset.xhtml?persistentId=hdl:1902.1/21538). 

We have selected a particular village to focus on. The dataset contains information on multiple different types of relationships. Our interest here is on relationships that were "double-sampled" in the original survey, meaning that they were elicited through two different prompts. For example, respondents were asked both _"If you needed to borrow kerosene or rice, to whom would you go?"_ as well as _"Who would come to you if he/she needed to borrow kerosene or rice?"_ These two different prompts should give us different perspectives on what could be the same relationship (i.e., we're asking $i$ if they **go** to $j$ for help, and also asking $j$ if $i$ **comes** to them for help). 

Four different tie types (or "layers") were double-sampled in this way (i.e., elicited with two prompts). Here, we will focus just on one tie type: the "visiting" relationship (based on two prompts: _"In your free time, whose house do you visit?" and "Who visits your house in his or her free time?"_). 

::: panel-tabset

## Load data.frame

After our preprocessing, the input data takes the form of the dataset given below. 

- `i`: the 'ego', generally the requester (required ‚úîÔ∏è)
- `j`: the 'alter', generally the giver (required ‚úîÔ∏è)
- `m`: the 'reporter', the person reporting on the tie (required ‚úîÔ∏è)
- `prompt_type`: the prompt type that was given (optional)
- `layer`: the tie type (optional)
- `weight`: the weight of the edge (optional)

Suppose we have a data frame `df_edges` of our village's data that looks like this:

```r
head(df_edges, 10)
```

```{r, echo = FALSE}
URL <- "https://raw.githubusercontent.com/latentnetworks/vimure/develop/data/input/india_microfinance/formatted/"
village <- "12" # change this parameter to run in other village
PATH <- paste0(URL, paste0("vil", village, "_edges.csv"))
df_edges <- read.csv(PATH, stringsAsFactors = F)

df_edges$layer <- factor(df_edges$type, 
  levels=c(
    "borrowmoney","receivemoney", "receiveadvice", "helpdecision",
    "keroricego", "keroricecome", "visitgo", "visitcome"
    ), labels=c("money", "money", "advice", "advice", "kerorice", "kerorice", "visit", "visit"))
layer <- "visit" # Change this to run for a different layer
df_edges <- df_edges[df_edges$layer %in% layer, ]
df_edges <- df_edges[df_edges$i != df_edges$j, ]

df_edges <- 
  df_edges %>% 
  rename(m=respondent, prompt_type=`type`) %>% 
  select(i, j, m, prompt_type, layer, weight) 
  
df_edges %>% 
  head(10) %>% 
  knitr::kable(row.names=FALSE, align = "cccccc", caption = "A typical data input for VIMuRe", full_width = FALSE)

```

## Load `igraph` object

Alternatively, you might have your data in the form of a **directed** `igraph` object. In this case, you must ensure that the `igraph` object has the following attributes:

- `m`: the 'reporter', the person reporting on the tie (required ‚úîÔ∏è)
- `prompt_type`: the prompt type that was given (optional)
- `layer`: the tie type (optional)
- `weight`: the weight of the edge (optional)

<!-- Let's first create a network (here, an `igraph` graph object) as might often be done: by taking the union of these two prompts (i.e., assuming that whether the tie is reported by $i$ or $j$, it exists -- the implication is that if one person didn't report a relationship that the other did, they simply forgot!). Note that the `graph_from_data_frame` function assumes that the first two columns in the data frame comprise the edgelist (i.e., the $i$ and $j$ columns, and treats all subsequent columns as edge attributes). 
 -->
```{r, echo = FALSE}
graph <- igraph::graph_from_data_frame(df_edges)
```

Suppose our village's data is in the form of an `igraph` object `graph`:

```{r}
graph
```

:::

## üìä Summary statistics

**Number of nodes**

::: panel-tabset

## data.frame

```{r}
dplyr::union(df_edges$i, df_edges$j) %>% n_distinct()
```

## `igraph` object

```{r}
igraph::vcount(graph)
```

:::


**Number of reporters**

::: panel-tabset

## data.frame

```{r}
df_edges$m %>% n_distinct()
```

## `igraph` object

```{r}
igraph::get.edge.attribute(graph, "m") %>% unique() %>% length()
```

:::

**Average number of ties per reporter**

There are a couple of things to note about this dataset: the maximum number of name generators is 4 and reporters can only report on ties that they are a part of (e.g., if a reporter is not a part of a tie, they cannot report on it). Because we are modelling double-sampled questions, each reporter can report a maximum of 8 ties.


::: panel-tabset

## data.frame

```{r, fig.width=6, fig.height=4}
df_edges %>% 
  group_by(m) %>% 
  summarise(n = n()) %>% 
  ggplot(aes(x = n)) +
  geom_histogram(bins = 30) +
  theme_bw() +
  labs(x = "Number of ties per reporter", y = "Number of reporters")
```

## `igraph` object

```{r, fig.width=6, fig.height=4}
igraph::get.edge.attribute(graph, "m") %>% 
  table() %>% 
  as.data.frame() %>% 
  ggplot(aes(x = Freq)) +
  geom_histogram(bins = 30) +
  theme_bw() +
  labs(x = "Number of ties per reporter", y = "Number of reporters")
```

:::

**Concordance**

_(üöß This is a work in progress. üöß)_

```r
  #concordance
  summats <- get.adjacency(incoming)+get.adjacency(outgoing)
  present <- sum(summats==2) #ties reported by both
  null <- sum(summats==0)-vcount(incoming) #reported by no one, subtract the diagonal
  net1 <- sum(get.adjacency(incoming)-get.adjacency(network_intersections[[counter]]))
  net2 <- sum(get.adjacency(outgoing)-get.adjacency(network_intersections[[counter]]))
  concord_prop <- present/(present+net1+net2)
  net1_concord_prop <- present/(present+net1) ## proportion of net1 edges that have agreement
  net2_concord_prop <- present/(present+net2) ## proportion of net2 edges that have agreement
  net1_prop <- net1/(present+net1+net2) ## proportion of all edges that are only reported in net1
  net2_prop <- net2/(present+net1+net2) ## proportion of all edges that are only reported in net2
  net1_mut <- dyad.census(incoming)$mut
  net2_mut <- dyad.census(outgoing)$mut
  union_mut <- dyad.census(network_unions[[counter]])$mut
```

::: panel-tabset

## data.frame



## `igraph` object



:::