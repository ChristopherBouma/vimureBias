---
title: "ðŸ“š Python package documentation"
subtitle: "VIMuRe v0.1 (latest)"
---
Module `vimure.synthetic`

Code to generate synthetic networks that emulates directed double-sample questions networks

## Functions

`def build_custom_theta(gt_network:Â [BaseSyntheticNetwork](#vimure.synthetic.BaseSyntheticNetwork "vimure.synthetic.BaseSyntheticNetwork"), theta_ratio:Â floatÂ =Â 0.5, exaggeration_type:Â strÂ =Â 'over', seed:Â intÂ =Â None)`

Instead of the regular generative model for `theta ~ Gamma(sh,sc)`,
create a more extreme scenario where some percentage of reporters are exaggerating.


## Parameters

**`gt_network`** :â€‚[`BaseSyntheticNetwork`](vimure.#vimure.synthetic.BaseSyntheticNetwork)
Generative ground truth model.
**`theta_ratio`** :â€‚`float`
Percentage of reporters who exaggerate.
**`exaggeration_type`** :â€‚`str`
("over", "under")
**`seed`** :â€‚`int`
If not set, use gt_network.prng instead.

## Returns

**`theta`** :â€‚`numpy.array`
A L x M matrix for theta.

`def build_self_reporter_mask(gt_network)`

Build the reporters' mask in a way such that:


* A reporter `m` can report ties in which she is ego:
`m --> i`
* A reporter `m` can report ties in which she is alter: `i --> m`
* A reporter `m` **cannot** report ties she is not involved, that is `i --> j` where `i != m` and `j != m`


## Parameters

**`gt_network`** :â€‚[`BaseSyntheticNetwork`](vimure.#vimure.synthetic.BaseSyntheticNetwork)
Generative ground truth model.

`def transpose_ij(M)`

Compute the transpose of a matrix.


## Parameters

**`M`** :â€‚`numpy.array`
Numpy matrix.

## Returns


Transpose of the matrix.

## Classes

`class BaseSyntheticNetwork
(N:Â intÂ =Â 100, M:Â intÂ =Â 100, L:Â intÂ =Â 1, K:Â intÂ =Â 2, seed:Â intÂ =Â 10, **kwargs)`

A base abstract class for generation and management of synthetic networks.
Suitable for representing any type of synthetic network (whether SBM or not).


## Parameters

**`N`** :â€‚`int`
Number of nodes.
**`M`** :â€‚`int`
Number of reporters.
**`L`** :â€‚`int`
Number of layers.
**`K`** :â€‚`int`
Maximum edge weight in the adjacency matrix.
When `K=2`, the adjacency matrix will contain some `Y_{ij}=0` and `Y_{ij}=1`.
**`seed`** :â€‚`int`
Pseudo random generator seed to use.

### Ancestors


* [BaseNetwork](io.html#vimure.io.BaseNetwork "vimure.io.BaseNetwork")


### Subclasses


* [HollandLaskeyLeinhardtModel](#vimure.synthetic.HollandLaskeyLeinhardtModel "vimure.synthetic.HollandLaskeyLeinhardtModel")
* [StandardSBM](#vimure.synthetic.StandardSBM "vimure.synthetic.StandardSBM")


### Methods

`def build_X(self, mutuality:Â floatÂ =Â 0.5, sh_theta:Â floatÂ =Â 2.0, sc_theta:Â floatÂ =Â 0.5, flag_self_reporter:Â boolÂ =Â True, cutoff_X:Â boolÂ =Â False, lambda_diff:Â floatÂ =Â None, Q:Â intÂ =Â None, seed:Â intÂ =Â None, theta:Â numpy.ndarrayÂ =Â None, verbose:Â boolÂ =Â False)`

Any object inhereted from BaseSyntheticNetwork will have a ground truth network Y.
Given that Y, generate the observed network X.


## Parameters

**`mutuality`** :â€‚`float`
The mutuality parameter from 0 to 1.
**`sh_theta`** :â€‚`float`
Shape of gamma distribution from which to draw theta.
The 'reliability' of nodes is represented by the parameter `theta_{lm}`
and by default are modelled as a gamma function with shape `sh_theta` and scale `sc_theta`.
**`sc_theta`** :â€‚`float`
Scale of gamma distribution from which to draw theta.
**`flag_self_reporter`** :â€‚`bool`
Indicates whether a node can only report about their own ties.
**`Q`** :â€‚`int`
Maximum value of X entries. If None, it will use the network's K parameter.
**`cutoff_X`** :â€‚`bool`
Whether to set X as a binary.
**`lambda_diff`** :â€‚`float`
The difference between each subsequent K.
**`seed`** :â€‚`int`
Pseudo random generator seed to use.
**`verbose`** :â€‚`bool`
Provides additional details.

## Returns

**`X`** :â€‚`sktensor`
Observed network.

`def build_Y(self)`

`def generate_lv(self)`

### Inherited members


* `**[BaseNetwork](io.html#vimure.io.BaseNetwork "vimure.io.BaseNetwork")**`:
	+ [`get_layer`](vimure.io.html#vimure.io.BaseNetwork.get_layer)

`class DegreeCorrectedSBM
(exp_in:Â floatÂ =Â 2, exp_out:Â floatÂ =Â 2.5, **kwargs)`

**Degree-corrected stochastic blockmodel.**


A generative model that incorporates heterogeneous vertex degrees into stochastic blockmodels, improving the performance of the models for statistical inference of group structure.
For more information about this model, see Karrer, B., & Newman, M. E. (2011). *Stochastic blockmodels and community structure in networks*. Physical review E, 83(1), 016107.
[DOI:10.1103/PhysRevE.83.016107](https://arxiv.org/pdf/1008.3926.pdf).


## Parameters

**`exp_in`** :â€‚`float`
Exponent power law of in-degree distribution.
**`exp_out`** :â€‚`float`
Exponent power law of out-degree distribution.
**`kwargs`**
Additional arguments of [`StandardSBM`](vimure.#vimure.synthetic.StandardSBM)

### Ancestors


* [StandardSBM](#vimure.synthetic.StandardSBM "vimure.synthetic.StandardSBM")
* [BaseSyntheticNetwork](#vimure.synthetic.BaseSyntheticNetwork "vimure.synthetic.BaseSyntheticNetwork")
* [BaseNetwork](io.html#vimure.io.BaseNetwork "vimure.io.BaseNetwork")


### Methods

`def generate_lv(self)`

Overwrite standard SBM model to add degree distribution

### Inherited members


* `**[StandardSBM](#vimure.synthetic.StandardSBM "vimure.synthetic.StandardSBM")**`:
	+ [`build_X`](vimure.#vimure.synthetic.BaseSyntheticNetwork.build_X)
	+ [`build_Y`](vimure.#vimure.synthetic.StandardSBM.build_Y)
	+ [`get_layer`](vimure.io.html#vimure.io.BaseNetwork.get_layer)
	+ [`init_sbm_params`](vimure.#vimure.synthetic.StandardSBM.init_sbm_params)

`class HollandLaskeyLeinhardtModel
(**kwargs)`

A base abstract class for generation and management of synthetic networks.
Suitable for representing any type of synthetic network (whether SBM or not).


## Parameters

**`N`** :â€‚`int`
Number of nodes.
**`M`** :â€‚`int`
Number of reporters.
**`L`** :â€‚`int`
Number of layers.
**`K`** :â€‚`int`
Maximum edge weight in the adjacency matrix.
When `K=2`, the adjacency matrix will contain some `Y_{ij}=0` and `Y_{ij}=1`.
**`seed`** :â€‚`int`
Pseudo random generator seed to use.

### Ancestors


* [BaseSyntheticNetwork](#vimure.synthetic.BaseSyntheticNetwork "vimure.synthetic.BaseSyntheticNetwork")
* [BaseNetwork](io.html#vimure.io.BaseNetwork "vimure.io.BaseNetwork")


### Inherited members


* `**[BaseSyntheticNetwork](#vimure.synthetic.BaseSyntheticNetwork "vimure.synthetic.BaseSyntheticNetwork")**`:
	+ [`build_X`](vimure.#vimure.synthetic.BaseSyntheticNetwork.build_X)
	+ [`get_layer`](vimure.io.html#vimure.io.BaseNetwork.get_layer)

`class Multitensor
(eta=0.5, ExpM=None, **kwargs)`

**A generative model with reciprocity**


A mathematically principled generative model for capturing both community and reciprocity patterns in directed networks.
Adapted from Safdari H., Contisciani M. & De Bacco C. (2021). Generative model for reciprocity and community detection in networks, Phys. Rev. Research 3, 023209.
[DOI:10.1103/PhysRevResearch.3.023209](https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.3.023209).


Generate a directed, possibly weighted network by using the reciprocity generative model.
Can be used to generate benchmarks for networks with reciprocity.


## Steps


1. Generate the latent variables.
2. Extract `A_{ij}` entries (network edges) from a Poisson distribution; its mean depends on the latent variables.

Note:â€‚Open Source code available at <https://github.com/mcontisc/CRep> and modified in accordance with its [license](https://github.com/mcontisc/CRep/blob/master/LICENSE).

---


Copyright (c) 2020 Hadiseh Safdari, Martina Contisciani and Caterina De Bacco.


## Parameters

**`eta`** :â€‚`float`
Initial value for the reciprocity coefficient. Eta has to be in [0, 1).
**`ExpM`** :â€‚`int`
Expected number of edges
**`kwargs`**
Additional arguments of [`StandardSBM`](vimure.#vimure.synthetic.StandardSBM)

### Ancestors


* [StandardSBM](#vimure.synthetic.StandardSBM "vimure.synthetic.StandardSBM")
* [BaseSyntheticNetwork](#vimure.synthetic.BaseSyntheticNetwork "vimure.synthetic.BaseSyntheticNetwork")
* [BaseNetwork](io.html#vimure.io.BaseNetwork "vimure.io.BaseNetwork")


### Methods

`def Exp_ija_matrix(self, u, v, w)`

Compute the mean lambda0_ij for all entries.


## Parameters

**`u`** :â€‚`numpy.array`
Out-going membership matrix.
**`v`** :â€‚`numpy.array`
In-coming membership matrix.
**`w`** :â€‚`numpy.array`
Affinity matrix.

## Returns

**`M`** :â€‚`numpy.array`
Mean `lambda^{0}_{ij}` for all entries.

`def build_Y(self)`

Generate network layers G and adjacency matrix A using the latent variables,
with the generative model `(A_{ij},A_{ji}) ~ P(A_{ij}|u,v,w,eta) P(A_{ji}|A_{ij},u,v,w,eta)`

### Inherited members


* `**[StandardSBM](#vimure.synthetic.StandardSBM "vimure.synthetic.StandardSBM")**`:
	+ [`build_X`](vimure.#vimure.synthetic.BaseSyntheticNetwork.build_X)
	+ [`generate_lv`](vimure.#vimure.synthetic.StandardSBM.generate_lv)
	+ [`get_layer`](vimure.io.html#vimure.io.BaseNetwork.get_layer)
	+ [`init_sbm_params`](vimure.#vimure.synthetic.StandardSBM.init_sbm_params)

`class StandardSBM
(C:Â intÂ =Â 2, structure:Â strÂ =Â None, avg_degree:Â floatÂ =Â 2, sparsify:Â boolÂ =Â True, overlapping:Â floatÂ =Â 0.0, **kwargs)`

**Creates a standard stochastic block-model synthetic network.**


A generative graph model which assumes the probability of connecting two nodes in a graph is determined entirely by their block assignments.
For more information about this model, see Holland, P. W., Laskey, K. B., & Leinhardt, S. (1983). *Stochastic blockmodels: First steps. Social networks*, 5(2), 109-137.
[DOI:10.1016/0378-8733(83)90021-7](https://www.sciencedirect.com/science/article/abs/pii/0378873383900217)


## Parameters

**`C`** :â€‚`int`
Number of communities
**`structure`** :â€‚`str`
Structures for the affinity tensor `w`. It can be 'assortative' or 'disassortative'.
It can be a list to map structure for each layer in a multilayer graph.
**`avg_degree`** :â€‚`float`
Desired average degree for the network. It is not guaranteed that the
ultimate network will have that exact average degree value.
Try tweaking this parameter if you want to increase or decrease the
density of the network.
**`sparsify`** :â€‚`bool`
If True (default), enforce sparsity.
**`overlapping`** :â€‚`float`
Fraction of nodes with mixed membership. It has to be in [`0, 1)`.
**`kwargs`**
Additional arguments of `[StandardSBM`](vimure.#vimure.synthetic.StandardSBM)

### Ancestors


* [BaseSyntheticNetwork](#vimure.synthetic.BaseSyntheticNetwork "vimure.synthetic.BaseSyntheticNetwork")
* [BaseNetwork](io.html#vimure.io.BaseNetwork "vimure.io.BaseNetwork")


### Subclasses


* [DegreeCorrectedSBM](#vimure.synthetic.DegreeCorrectedSBM "vimure.synthetic.DegreeCorrectedSBM")
* [Multitensor](#vimure.synthetic.Multitensor "vimure.synthetic.Multitensor")


### Methods

`def build_Y(self)`

Latent variables

`def generate_lv(self)`

Generate latent variables for a Stochastic BlockModel, assuming network layers are independent.

`def init_sbm_params(self, **kwargs)`

Check SBM-specific parameters

### Inherited members


* `**[BaseSyntheticNetwork](#vimure.synthetic.BaseSyntheticNetwork "vimure.synthetic.BaseSyntheticNetwork")**`:
	+ [`build_X`](vimure.#vimure.synthetic.BaseSyntheticNetwork.build_X)
	+ [`get_layer`](vimure.io.html#vimure.io.BaseNetwork.get_layer)

# Index

* ### Super-module


	+ [`vimure`](vimure.index.html)
* ### [Functions](#header-functions)


	+ [`build_custom_theta`](vimure.#vimure.synthetic.build_custom_theta)
	+ [`build_self_reporter_mask`](vimure.#vimure.synthetic.build_self_reporter_mask)
	+ [`transpose_ij`](vimure.#vimure.synthetic.transpose_ij)
* ### [Classes](#header-classes)


	+ #### [`BaseSyntheticNetwork`](vimure.#vimure.synthetic.BaseSyntheticNetwork)
	
	
		- [`build_X`](vimure.#vimure.synthetic.BaseSyntheticNetwork.build_X)
		- [`build_Y`](vimure.#vimure.synthetic.BaseSyntheticNetwork.build_Y)
		- [`generate_lv`](vimure.#vimure.synthetic.BaseSyntheticNetwork.generate_lv)
	+ #### [`DegreeCorrectedSBM`](vimure.#vimure.synthetic.DegreeCorrectedSBM)
	
	
		- [`generate_lv`](vimure.#vimure.synthetic.DegreeCorrectedSBM.generate_lv)
	+ #### [`HollandLaskeyLeinhardtModel`](vimure.#vimure.synthetic.HollandLaskeyLeinhardtModel)
	+ #### [`Multitensor`](vimure.#vimure.synthetic.Multitensor)
	
	
		- [`Exp_ija_matrix`](vimure.#vimure.synthetic.Multitensor.Exp_ija_matrix)
		- [`build_Y`](vimure.#vimure.synthetic.Multitensor.build_Y)
	+ #### [`StandardSBM`](vimure.#vimure.synthetic.StandardSBM)
	
	
		- [`build_Y`](vimure.#vimure.synthetic.StandardSBM.build_Y)
		- [`generate_lv`](vimure.#vimure.synthetic.StandardSBM.generate_lv)
		- [`init_sbm_params`](vimure.#vimure.synthetic.StandardSBM.init_sbm_params)

Generated by [pdoc 0.10.0](https://pdoc3.github.io/pdoc "pdoc: Python API documentation generator").

